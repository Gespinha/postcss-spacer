var postcss = require('postcss');

module.exports = postcss.plugin('spacer', function spacer(options) {
  "use strict";

  return function (css) {
    options = options || {
      'comment-pattern': false,
      'lines-before': false,
      'lines-after': false
    };
    var commentPattern = options['comment-pattern'],
        linesBefore = options['lines-before'],
        linesAfter = options['lines-after'];

    var updateCount = 0;

    // helper functions
    function addLineSpace(position){
      return new Array(options['lines-' + position] + 2).join('\n');
    }

    function updateComments(comment){
      if(linesBefore && css.nodes[0] !== comment){
        comment.raws.before = addLineSpace('before');
      }
      if(linesAfter && comment.next() !== undefined){
        comment.next().raws.before = addLineSpace('after');
      }
      return updateCount++;
    }

    // processor actions
    if(!commentPattern){

      css.walkComments(function(comment){
        updateComments(comment);
      });
      console.log('Updated ' + updateCount + ' comment' + (updateCount > 1 ? 's' : ''));

    } else if(typeof(commentPattern) === 'object' && commentPattern.length > 0){

      css.walkComments(function(comment){
        var updateComment = false;

        for(var i = 0; i < commentPattern.length; i++){
          updateComment = (!updateComment ? comment.toString().indexOf(commentPattern[i]) > -1 : true);
        }
        if(updateComment){
          updateComments(comment);
        }
      });
      console.log('Updated ' + updateCount + ' comment' + (updateCount > 1 ? 's' : '') + ' from ' + commentPattern.length + ' patterns');

    } else {

      console.log('Comment Pattern options value must be an object');

    }
  }
});